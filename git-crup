#!/bin/bash
# Copyright (c) 2012 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# A convenience script to largely replicate the behavior of `gclient sync` in a
# submodule-based checkout.  Fetches latest commits for top-level solutions;
# updates submodules; and runs post-sync hooks.

# Auto-update depot_tools
if [ -z "$GIT_CRUP_REINVOKE" ]; then
  update_depot_tools || exit 1
  GIT_CRUP_REINVOKE=1 exec bash "$0" "$@"
fi

export GIT_MERGE_AUTOEDIT=0

ECHO=
pull=pull
pull_args=
hooks=yes
j=10
crup_runner="crup-runner.sh"
runhooks="git-runhooks"

kernel_name=$(uname -s)
if [ "${kernel_name:0:5}" = "MINGW" -o "${kernel_name:0:6}" = "CYGWIN" ]; then
  GIT_EXE=git.exe
else
  GIT_EXE=git
fi
export GIT_EXE

if ( echo test | xargs --max-lines=1 true 2>/dev/null ); then
  max_lines="--max-lines=1"
else
  max_lines="-L 1"
fi

if ( echo test | xargs -I bar true 2>/dev/null ); then
  replace_arg="-I replace_arg"
else
  replace_arg="-ireplace_arg"
fi

usage() {
  cat <<EOF
Usage: git-crup [-n|--dry-run] [--fetch] [-j|--jobs [jobs]]
    [--no-hooks] [<args to git-pull or git-fetch>]
EOF
}

serial_update() {
  ( cd "$1"
    $GIT_EXE $pull $pull_args -q origin | sed "s/^/[$1] /g"
    if [ $? -ne 0 ]; then
      return $?
    fi
    $GIT_EXE submodule --quiet sync
    $GIT_EXE ls-files -s | grep ^160000 | awk '{print $4}' |
    while read submod; do
      "$crup_runner" "$1/$submod"
    done
  )
}

while test $# -ne 0; do
  case "$1" in
    -j[0-9]*)
      j=$(echo "$1" | cut -c3-)
      ;;
    --jobs=[0-9]*)
      j=$(echo "$1" | cut -c8-)
      ;;
    -j|--jobs)
      case "$2" in
        ''|-*)
          j=0
          ;;
        *)
          j="$2"
          shift
          ;;
      esac
      ;;
    -n|--dry-run)
      ECHO=echo
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    --fetch)
      pull=fetch
      ;;
    --no-hooks|--nohooks)
      hooks=no
      ;;
    *)
      pull_args="$pull_args $1"
      break
      ;;
  esac
  shift
done

while test "$PWD" != "/"; do
  if test -f "$PWD/src/.gitmodules"; then
    break
  fi
  cd ..
done
if test "$PWD" = "/"; then
  echo "Could not find the root of your checkout; aborting." 1>&2
  exit 1
fi

if ( echo test test | xargs -P 2 true 2>/dev/null ); then
  xargs_parallel=yes
else
  if test "$j" != "1"; then
    echo "Warning: parallel execution is not supported on this platform." 1>&2
  fi
  xargs_parallel=no
fi

set -o pipefail
if test "$xargs_parallel" = "yes"; then
  ( ls -d */.git | sed 's/\/\.git$//' |
   xargs $max_lines $replace_arg -P "$j" \
      "$crup_runner" replace_arg $GIT_EXE $pull $pull_args -q origin |
   xargs $max_lines -P "$j" "$crup_runner" )
else 
  ls -d */.git |
  while read gitdir; do
    serial_update "${gitdir%%/.git}"
  done
fi

status=$?

if [ "$hooks" = "yes" -a "$status" -eq 0 ]; then
  "$runhooks"
  status=$?
fi

echo
exit $status
